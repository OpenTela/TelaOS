#!/usr/bin/env python3
"""
create_embedded_icons.py - Pre-build script for embedding app icons

Scans data/apps/*/icon.png and generates _generated_icons.h
with RGB565 pixel data for use in launcher without PNG decoding.

Hybrid system: embedded icons used at runtime, FS fallback for new/changed icons.
Each icon stores original PNG file size for staleness detection.

Usage:
  PlatformIO: extra_scripts = pre:scripts/create_embedded_icons.py
  Debug mode: python create_embedded_icons.py -d icon.png
"""

SCRIPT_VERSION = "3.0"

import os
import sys
import tempfile
from pathlib import Path

try:
    from PIL import Image
except ImportError:
    print("ERROR: Pillow required. Install: pip install Pillow")
    sys.exit(1)

# Launcher background color: 0x0a0a12
BG_R, BG_G, BG_B = 0x0a, 0x0a, 0x12
DEFAULT_SIZE = 64


def rgb888_to_rgb565(r, g, b):
    """Convert RGB888 to RGB565"""
    rgb565 = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3)
    return rgb565 & 0xFF, (rgb565 >> 8) & 0xFF  # little-endian


def rgb565_to_rgb888(lo, hi):
    """Convert RGB565 back to RGB888 for preview"""
    rgb565 = lo | (hi << 8)
    r = ((rgb565 >> 11) & 0x1F) << 3
    g = ((rgb565 >> 5) & 0x3F) << 2
    b = (rgb565 & 0x1F) << 3
    return r, g, b


def process_icon(png_path, max_size=DEFAULT_SIZE):
    """Load PNG and convert to RGB565 with alpha blending to background"""
    img = Image.open(png_path)
    
    if img.mode != 'RGBA':
        img = img.convert('RGBA')
    
    # Resize to fit in max_size, maintaining aspect ratio
    if img.width > max_size or img.height > max_size:
        img.thumbnail((max_size, max_size), Image.LANCZOS)
    
    # Make square with transparent padding
    if img.width != img.height or img.width != max_size:
        square = Image.new('RGBA', (max_size, max_size), (0, 0, 0, 0))
        paste_x = (max_size - img.width) // 2
        paste_y = (max_size - img.height) // 2
        square.paste(img, (paste_x, paste_y))
        img = square
    
    width, height = img.size
    pixels = list(img.getdata())
    
    rgb565_bytes = []
    transparent_count = 0
    
    for r, g, b, a in pixels:
        if a < 255:
            transparent_count += 1
            alpha = a / 255.0
            r = int(r * alpha + BG_R * (1 - alpha))
            g = int(g * alpha + BG_G * (1 - alpha))
            b = int(b * alpha + BG_B * (1 - alpha))
        lo, hi = rgb888_to_rgb565(r, g, b)
        rgb565_bytes.extend([lo, hi])
    
    return width, height, bytes(rgb565_bytes), transparent_count


def test_single_icon(png_path):
    """Test mode: convert single icon and save preview"""
    print(f"Testing: {png_path}")
    
    width, height, data, transparent = process_icon(png_path)
    print(f"  Size: {width}x{height}")
    print(f"  Transparent pixels: {transparent}")
    print(f"  Output bytes: {len(data)}")
    
    # Convert back to RGB for preview
    preview = Image.new('RGB', (width, height))
    pixels = []
    for i in range(0, len(data), 2):
        r, g, b = rgb565_to_rgb888(data[i], data[i+1])
        pixels.append((r, g, b))
    preview.putdata(pixels)
    
    # Save to temp
    output_path = Path(tempfile.gettempdir()) / "icon_preview.png"
    preview.save(output_path)
    print(f"  Preview: {output_path}")
    
    # Open it
    if sys.platform == 'win32':
        os.startfile(output_path)
    elif sys.platform == 'darwin':
        os.system(f'open "{output_path}"')
    else:
        os.system(f'xdg-open "{output_path}" 2>/dev/null || echo "Open manually"')


# === CLI mode ===
if __name__ == "__main__":
    if len(sys.argv) >= 3 and sys.argv[1] == "-d":
        test_single_icon(sys.argv[2])
        sys.exit(0)
    else:
        print("Debug mode: python create_embedded_icons.py -d <icon.png>")
        print("Build mode: Run via PlatformIO")
        sys.exit(0)


# === PlatformIO mode ===
try:
    Import("env")
    HAS_ENV = True
except:
    HAS_ENV = False

if not HAS_ENV:
    sys.exit(0)


def sanitize_name(name):
    """Convert app name to valid C identifier"""
    return name.replace('-', '_').replace(' ', '_').replace('.', '_')


def generate_header(icons_data, output_path, icon_size=DEFAULT_SIZE):
    """Generate C header with embedded icons and PNG sizes for staleness check"""
    
    has_icons = len(icons_data) > 0
    
    lines = [
        "// === AUTO-GENERATED FILE - DO NOT EDIT! ===",
        f"// SCRIPT_VERSION: {SCRIPT_VERSION}",
        f"// ICON_SIZE: {icon_size}",
        "// Generated by scripts/create_embedded_icons.py",
        "",
        "#pragma once",
        "#include <lvgl.h>",
        "#include <cstring>",
        "#include <cstdio>",
        "",
    ]
    
    if has_icons:
        lines.append("// Icons found at build time — always active")
        lines.append("#ifndef NO_BUILTIN_ICONS")
        lines.append("#define USE_BUILTIN_ICONS")
        lines.append("#endif")
        lines.append("")
        lines.append("#ifdef USE_BUILTIN_ICONS")
        lines.append("")
    
        for app_name, (width, height, data, png_size) in icons_data.items():
            safe_name = sanitize_name(app_name)
            data_size = len(data)
            
            lines.append(f"// {app_name}: {width}x{height} RGB565 ({data_size}B, png={png_size}B)")
            lines.append(f"static const uint8_t _icon_{safe_name}_data[] PROGMEM = {{")
            
            for i in range(0, len(data), 16):
                chunk = data[i:i+16]
                hex_str = ", ".join(f"0x{b:02X}" for b in chunk)
                lines.append(f"    {hex_str},")
            
            lines.append("};")
            lines.append("")
            lines.append(f"static const lv_image_dsc_t _icon_{safe_name} = {{")
            lines.append(f"    .header = {{ .cf = LV_COLOR_FORMAT_RGB565, .w = {width}, .h = {height} }},")
            lines.append(f"    .data_size = {data_size},")
            lines.append(f"    .data = _icon_{safe_name}_data")
            lines.append("};")
            lines.append("")
        
        # Lookup table with png_size for staleness detection
        lines.append("struct BuiltinIcon {")
        lines.append("    const char* name;")
        lines.append("    const lv_image_dsc_t* icon;")
        lines.append("    uint32_t png_size;  // original PNG file size — if FS differs, icon was updated")
        lines.append("};")
        lines.append("")
        lines.append("static const BuiltinIcon _builtin_icons[] = {")
        
        for app_name, (width, height, data, png_size) in icons_data.items():
            safe_name = sanitize_name(app_name)
            lines.append(f'    {{ "{app_name}", &_icon_{safe_name}, {png_size} }},')
        
        lines.append("    { nullptr, nullptr, 0 }")
        lines.append("};")
        lines.append("")
        
        # Entry lookup (returns full struct for size check)
        lines.append("// Returns full entry with png_size for staleness check")
        lines.append("static inline const BuiltinIcon* findBuiltinEntry(const char* name) {")
        lines.append("    for (const auto& entry : _builtin_icons) {")
        lines.append("        if (entry.name && strcmp(entry.name, name) == 0) {")
        lines.append("            return &entry;")
        lines.append("        }")
        lines.append("    }")
        lines.append("    return nullptr;")
        lines.append("}")
        lines.append("")
        
        # Legacy compat — returns just the descriptor
        lines.append("static inline const lv_image_dsc_t* findBuiltinIcon(const char* name) {")
        lines.append("    auto* e = findBuiltinEntry(name);")
        lines.append("    return e ? e->icon : nullptr;")
        lines.append("}")
        lines.append("")
        lines.append("static inline const lv_image_dsc_t* findCategoryIcon(const char* category) {")
        lines.append("    if (!category || !category[0]) return nullptr;")
        lines.append("    char buf[64];")
        lines.append('    snprintf(buf, sizeof(buf), "_category_%s", category);')
        lines.append("    return findBuiltinIcon(buf);")
        lines.append("}")
        lines.append("")
        lines.append("static inline const lv_image_dsc_t* findSystemIcon(const char* name) {")
        lines.append("    if (!name || !name[0]) return nullptr;")
        lines.append("    char buf[64];")
        lines.append('    snprintf(buf, sizeof(buf), "_system_%s", name);')
        lines.append("    return findBuiltinIcon(buf);")
        lines.append("}")
        lines.append("")
        lines.append("static inline const BuiltinIcon* findSystemEntry(const char* name) {")
        lines.append("    if (!name || !name[0]) return nullptr;")
        lines.append("    char buf[64];")
        lines.append('    snprintf(buf, sizeof(buf), "_system_%s", name);')
        lines.append("    return findBuiltinEntry(buf);")
        lines.append("}")
        lines.append("")
        lines.append("#endif // USE_BUILTIN_ICONS")
        lines.append("")
    
    # Stubs when no builtin icons (proper LVGL types for compilation safety)
    lines.append("#ifndef USE_BUILTIN_ICONS")
    lines.append("struct BuiltinIcon { const char* name; const lv_image_dsc_t* icon; uint32_t png_size; };")
    lines.append("static inline const BuiltinIcon* findBuiltinEntry(const char*) { return nullptr; }")
    lines.append("static inline const lv_image_dsc_t* findBuiltinIcon(const char*) { return nullptr; }")
    lines.append("static inline const lv_image_dsc_t* findCategoryIcon(const char*) { return nullptr; }")
    lines.append("static inline const lv_image_dsc_t* findSystemIcon(const char*) { return nullptr; }")
    lines.append("static inline const BuiltinIcon* findSystemEntry(const char*) { return nullptr; }")
    lines.append("#endif // !USE_BUILTIN_ICONS")
    lines.append("")
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    
    return len(icons_data)


def needs_regeneration(output_path, icon_paths, script_path, icon_size):
    """Check if header needs to be regenerated"""
    if not output_path.exists():
        return True, "header missing"
    
    output_mtime = output_path.stat().st_mtime
    
    # Check if script is newer
    if script_path.exists() and script_path.stat().st_mtime > output_mtime:
        return True, "script updated"
    
    # Check version and icon_size in header
    try:
        with open(output_path, 'r', encoding='utf-8') as f:
            header = f.read(500)
            if f"SCRIPT_VERSION: {SCRIPT_VERSION}" not in header:
                return True, "version mismatch"
            if f"ICON_SIZE: {icon_size}" not in header:
                return True, "size changed"
    except:
        return True, "header unreadable"
    
    # Check if any icon is newer
    for icon_path in icon_paths:
        if icon_path.stat().st_mtime > output_mtime:
            return True, f"{icon_path.parent.name} updated"
    
    return False, "up to date"


def main():
    project_dir = Path(env.subst("$PROJECT_DIR"))
    data_dir = project_dir / "data" / "apps"
    output_path = project_dir / "include" / "_generated_icons.h"
    script_path = project_dir / "scripts" / "create_embedded_icons.py"
    
    # Get icon size from platformio.ini (custom_icon_size) or use default
    try:
        icon_size = int(env.GetProjectOption("custom_icon_size", str(DEFAULT_SIZE)))
    except:
        icon_size = DEFAULT_SIZE
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    if not data_dir.exists():
        print("=== Embedded Icons ===")
        print(f"  No apps dir: {data_dir}")
        generate_header({}, output_path, icon_size)
        return
    
    # Collect icon paths - app icons
    icon_paths = []
    for app_dir in sorted(data_dir.iterdir()):
        if app_dir.is_dir():
            icon_path = app_dir / "icon.png"
            if icon_path.exists():
                icon_paths.append(icon_path)
    
    # Collect system category icons
    system_icons_dir = data_dir.parent / "system" / "resources" / "icons"
    system_icon_paths = []
    if system_icons_dir.exists():
        system_icon_paths = list(system_icons_dir.glob("*.png"))
        icon_paths.extend(system_icon_paths)
    
    # Check if regeneration needed
    needs_regen, reason = needs_regeneration(output_path, icon_paths, script_path, icon_size)
    
    if not needs_regen:
        print(f"=== Embedded Icons ({icon_size}x{icon_size}): {reason} ===")
        return
    
    print(f"=== Embedded Icons {icon_size}x{icon_size} ({reason}) ===")
    
    icons_data = {}
    total_bytes = 0
    total_transparent = 0
    
    # Process app icons
    for app_dir in sorted(data_dir.iterdir()):
        if not app_dir.is_dir():
            continue
        icon_path = app_dir / "icon.png"
        if not icon_path.exists():
            continue
        
        app_name = app_dir.name
        png_size = icon_path.stat().st_size
        try:
            width, height, data, transparent = process_icon(icon_path, icon_size)
            icons_data[app_name] = (width, height, data, png_size)
            total_bytes += len(data)
            total_transparent += transparent
            print(f"  {app_name}: {width}x{height}, {png_size}B png, {transparent} transparent px")
        except Exception as e:
            print(f"  {app_name}: FAILED - {e}")
    
    # Process system icons (with _system_ prefix)
    for icon_path in sorted(system_icon_paths):
        icon_name = icon_path.stem
        system_name = f"_system_{icon_name}"
        png_size = icon_path.stat().st_size
        try:
            width, height, data, transparent = process_icon(icon_path, icon_size)
            icons_data[system_name] = (width, height, data, png_size)
            total_bytes += len(data)
            total_transparent += transparent
            print(f"  system:{icon_name}: {width}x{height}, {png_size}B png, {transparent} transparent px")
        except Exception as e:
            print(f"  system:{icon_name}: FAILED - {e}")
    
    count = generate_header(icons_data, output_path, icon_size)
    
    if count > 0:
        print(f"  Total: {count} icons, {total_bytes//1024}KB flash, {total_transparent} blended px")
    else:
        print("  No icons found")


main()
